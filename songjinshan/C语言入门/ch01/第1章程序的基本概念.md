# 1 程序和编程语言

**程序(Program)**：告诉计算机应如何完成一个计算任务，这里的计算任务可以是数学运算，如解方程。也可以是符号运算，如查找和替换文档中的单词。

从根本上说，计算机是由数字电路组成的运算机器，只能对数字做运算。程序之所以能做符号运算，是因为符号在计算机内部也是用数字表示的。

程序由一系列指令(Instruction)组成，指令是指示计算机做某种运算的命令，通常包括以下几类：

 - **输入(Input)**: 从键盘、文件或其它设备获取数据。
 - **输出(Output)**: 把数据显示到屏幕，或者存入一个文件，或者发送到其它设备。
 - **基本运算**: 执行最基本的**数学运算(加减乘除)和数据存取**。
 - **测试和分支**: 测试某个条件，然后根据不同的测试结果执行不同的后续指令。
 - **循环**: 重复执行一系列操作。

**任何一个程序，不管它有多复杂，都是由这几类指令组成的**。程序是如此复杂，而编写程序可以用 的指令却只有这么简单的几种，这中间巨大的落差就由程序员去填了，所有编写程序理应是一件相当复杂的工作。编写程序可以说就是这样一个过程：**把复杂的任务分解成子任务，把子任务分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成**。

编程语言(Programming Language): 分为低级语言(Low-level Language) 和高级语言(High-level Language)。

 - 低级语言： 直接用计算机指令编写程序。如机器语言(Machine Language), 汇编语言(Assembly Language)
 - 高级语言： 用语句(Statement)编写程序，语句是计算机指令的抽象表示。如C、C++、Java、Python等。

例如，同样一个语句用C语言、汇编语言、和机器语言分别表示如下：

| 编程语言 | 表示形式                                                     |
| -------- | ------------------------------------------------------------ |
| C语言    | a=b+1;                                                       |
| 汇编语言 | mov  0x804a01c, %eax<br /> add $0x1, %eax<br /> mov %eax, 0x804a018 |
| 机器语言 | a1 1c a0 04 08 <br /> 83 c0 01 <br /> a3 18 a0 04 08         |

计算机只能对数字做运算，**符号、声音、图像在计算机内部都要用数字表示，指令也不例外**。数字只的是二进制的0和1，但是处于表示上的方便，一般都是将二进制转化为十六进制的表示方式。如上表中的机器语言完全有十六进制数字组成。

汇编语言和机器语言是一一对应的，汇编语言有三条指令，机器语言也有三条指令，汇编器就是做一个简单的替换工作。如把mov  address, %eax这种格式替换成机器码a1 address，这种格式，address表示一个地址，在汇编指令中是0x804a01c，转换成机器码后是1c a0 04 08(这是指令中的十六进制数的小端表示)。

C语言的语句和低级语言的指令之间不是简单的一一对应关系，一条a=b+1;语句要翻译成三条汇编或机器指令，这个过程称为编译(Compile), 有编译器(Compiler)完成，显然编译器的功能比汇编器复杂得多。

虽然编译需要花一些时间，然而更多的是优点。首先，用C语言编程更容易，写出来的代码更紧凑，可读性更强，出了错误也容易更改。其次， C语言是可移植的(Portable)或称为平台无关的(Platform Independent).

平台这个此有很多中解释，可以指计算机体系结构(Architecture)，也可以指操作系统，也可以指开发平台(编译器、链接器等)。不同的计算机体系结构有不同的指令集(Instruction Set)，可以识别的机器指令格式是不同，直接用某种体系结构的汇编或机器指令写出来的程序只能在这种体系结构的计算机上运行，然而各种体系结构的计算机都有各自的C编译器，可以把C程序编译成各种不同体系结构的机器指令，这意味着用C语言写的程序只需稍加修改设置不用修改就可以在各种不同计算机上编译运行。只有和硬件关系密切的少数程序(如驱动程序)才会用到低级语言。还要注意一点，**即使在相同的体系结构和操作系统下，用不同的C编译器(或同一个C编译器的不同版本)编译同一个程序得到的结果也有可能不同，C语言的有些语法特性在C标准中并没有明确规定，各编译器有不同的实现，编译出来的指令的行为特性也会不同，应该尽量避免使用不可移植的语法特性**。

编译执行的过程：用编辑器写一个C程序，并保存成一个文件，如program.c，称为源代码(Source Code)或源文件；然后运行编译器，对其进行编译，编译的过程并不执行程序，而是把源代码全部翻译成机器指令，在加上一些描述信息，生成一个新的文件，如a.out，称为可执行文件；可执行文件被操作系统加载运行，计算机执行该文件中由编译器生成的指令。

解释型语言：解释器(Interpreter)把脚本中的每一行当做一条命令解释执行，而不需要先生成包含机器指令的可执行文件再执行。

# 2 自然语言和形式语言

自然语言(Nature Language): 人类讲的语言，不是人为设计的而是自然进化的。

形式语言(Formal Language): 为了特定的应用而人为设计的语言。

形式语言有严格的语法(Syntax)规则，语法规则由符号(Token)和结构(Structure)的规则组成。

# 3 程序的调试

**编译时错误**

编译器只能翻译语法正确的程序，否则将导致编译失败，无法生成可执行文件。

**运行时错误**

编译器检查不出这类错误，仍然可以生成可执行文件，但在运行时会出现错误导致程序崩溃。

**逻辑错误和语义错误**

如果程序里有逻辑错误，编译和运行都很顺利，看上去也不会产生任何错误信息，但是程序没有干它该干的事，而是干了别的事。

# 4 第一个程序

main.c

```c
#include <stdio.h>
/* main: generate some simple output*/
int main(void)
{
    printf("Hello World.\n");
    return 0;
}
```

```bash
$ gcc main.c
$ ./a.out
Hello World.
```

gcc是Linux平台的C编译器，编译后在当前目录下生成可执行文件a.out。如果不想把文件名叫a.out，可以用gcc的-o 参数指定文件名：

```bash
$ gcc main.c -o main
$ ./main
Hello World.
```

一个好的习惯是打开gcc的-Wall选项，也就是让gcc提示所有的警告信息，不管是严重的还是不严重的，然后把这些问题从代码中全部消灭。

因为警告信息不是致命错误，编译器仍然可以继续，如果整个编译过程只有警告信息而没有错误信息，仍然可以生成可执行文件。但警告信息也是不容忽视的。出警告信息说明你的程序写的不够规范，可能有Bug，虽然能编译生成可执行文件，但程序的运行结果往往不正确，如下面的程序运行时出了一个段错误，这属于运行时错误。

把上例中的printf("Hello World.\n");改成printf(1);然后编译运行：

```bash
$ gcc main.c
main.c: In function ‘main’:
main.c:7: warning: passing argument 1 of ‘printf’ makes pointer from
integer without a cast
$ ./a.out
Segmentation fault
```

各种警告信息的验证程度不同，想上面这种警告几乎一定表明程序中有Bug，而另外一些警告只表明程序写得不够规范，一般还是能正确运行的，有些不重要的警告信息gcc默认是不提示的，但这些警告信息也有可能表明程序中有Bug。

再如把上例中的printf("Hello World.\n");改成printf(0);然后编译运行：

```bash
$ gcc main.c
$ ./a.out
```

编译既不报错也不警告，一切正常，但是运行程序什么也不打印。如果打开-Wall选项编译会报警告了：

```bash
$ gcc -Wall main.c
main.c: In function ‘main’:
main.c:7: warning: null argument where non-null required (argument
1)
```

